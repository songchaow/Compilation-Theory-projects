# Homework 10-2

> PB15000102 王嵩超

## 系统信息

**OS:** Lubuntu 17.10

**CPU:** Intel i7 6700HQ

**Compiler:** gcc (Ubuntu 7.2.0-8ubuntu3) 7.2.0

## test目录说明

在该目录下，运行`make`命令即可生成两个problem的示例程序。problem 1的结果可以用gdb来查看内存数据得到。

## Problem 1 局部变量在栈空间中的排布

阅读`var_with_array.c`，画出栈的分配情况。并说明整型变量i, j, k中的哪一个最后再次被更改？

**Answer**

当用`-fno-stack-protector`选项编译时，栈的分配情况如图。注意图中的栈下方为低地址，上方为高地址。

──────────────────

i

──────────────────

j

──────────────────

k

──────────────────

array[9]

──────────────────

...

──────────────────

array[1]

──────────────────

array[0]

结合作业中的例子，可以得出，gcc会将同一个语句块中的局部变量连续地放置到活动记录中，且数组一般会被放到其他变量的下方(更低地址处)，即使在源程序中的定义顺序不是这样。

##Problem 2 动态内存分配的机制

通过malloc函数获得一个存储单元地址，继续向其右的地址访问，会不会出现segmentation fault？一般会读出什么数据？读多久会出现segmentation fault?

通过malloc函数多次分配地址，我们得到的地址是连续的吗？

**Answers**

堆内存，在现在的操作系统中以页为单位进行分配。一个页可能很大，而程序中每次所请求的空间只是几Byte的大小，故大多数情况下，malloc是从当前已有的页中标记一块空间并返回地址。若当前页不能给出足够的空间时，allocator再向操作系统索要更多的页。

程序运行结果为，初始分配给程序的堆空间大小为136KB。而且多次调用malloc请求1字节的空间，其返回的多个地址不是连续的。如此设计可能是为了安全性，让多次得到的存储空间不易互相影响。